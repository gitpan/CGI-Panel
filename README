NAME
    CGI::Panel - Create sophisticated event-driven web applications from
    simple panel objects

SYNOPSIS
      A very simple application...

        ---------------

      in simpleapp.cgi:

        use SimpleApp;
        my $simple_app = obtain SimpleApp;
        $simple_app->cycle();

        ---------------

      in SimpleApp.pm:

        package SimpleApp;

        use strict;
        use warnings;
        use Basket;
        use base qw(CGI::Panel::MainPanel);

        sub init {
            my ($self) = @_;
            $self->add_panel('basket', new Basket); # Add a sub-panel
            $self->{count} = 1;   # Initialise some persistent data
        }

        sub _event_add {    # Respond to the button click event below
            my ($self, $event) = @_;

            $self->{count}++;  # Change the persistent data
        }

        sub display {
            my ($self) = @_;

            return
                'This is a very simple app.<p>' .
                # Display the persistent data...
                "My current count is $self->{count}<p>" .
                # Display the sub-panel...
                $self->panel('basket')->display . '<p>' .
                # Display a button that will generate an event...
                $self->event_button(label => 'Add 1', name => 'add'); 
        }

        1;

        ---------------

      in Basket.pm:

        package Basket;
        use base qw(CGI::Panel);

        sub display {
            'I have the potential to be a shopping basket one day'
        }
        1;

        ---------------

DESCRIPTION
    CGI::Panel allows applications to be built out of simple object-based
    components. It'll handle the state of your data and objects so you can
    write a web application just like a desktop app. You can forget about
    the http requests and responses, whether we're getting or posting, and
    all that stuff because that is all handled for you leaving to you
    interact with a simple API.

    An application is constructed from a set of 'panels', each of which can
    contain other panels. The panels are managed behind the scenes as
    persistent objects. See the sample applications for examples of how
    complex object-based applications can be built from simple encapsulated
    components. (To do)

USAGE
    See 'SYNOPSIS'

BUGS
SUPPORT
AUTHOR
            Robert J. Symes
            CPAN ID: RSYMES
            rob@robsymes.com

COPYRIGHT
    Copyright (c) 2002 Robert J. Symes. All rights reserved. This program is
    free software; you can redistribute it and/or modify it under the same
    terms as Perl itself.

    The full text of the license can be found in the LICENSE file included
    with this module.

SEE ALSO
    perl(1).

PUBLIC METHODS
    Each public function/method is described here. These are how you should
    interact with this module.

  new
    Creates a new panel object

    Use:

        my $panel = new Panel;

  init
    Initialises a panel object. This should be used to add panels to the
    current panel. We provide a default method here which can be overridden.

    Example:

        sub init {
            my ($self) = @_;

            $self->add_panel('first_panel',  App::Panel::First);
            $self->add_panel('second_panel', App::Panel::Second);
        }

  parent
    Get or set the parent of the panel object.

    Examples: my $parent = $self->parent; $self->parent($other_panel);

  state
    This method is provided for convenience. Get or set the state. (Simple
    accessor for $self->{_state})

    Examples: my $state = $self->state; $self->state('STATE1');

  get_persistent_id
    Gets the session id for the application

    Note: It's essential that all panels are added using the proper
    add_panel routine. This routine traverses up to the main panel by way of
    each panel's 'parent' reference.

    Example:

        my $id = $self->get_persistent_id;

  panel
    Retrieves a panel by name

    Example:

        my $first_panel = $self->panel('first_panel');

  get_panels
    Retrieves the set of panels as a hash

    Example:

        my %panels = $self->get_panels;

  add_panel
    Adds a panel to the current panel in a way that maintains referential
    integrity, ie the child panel's parent value will be set to the current
    panel. All panels should be added to their parents using this routine to
    keep referential integrity and allow certain other mechanisms to work.

    Example:

        $self->add_panel('first_panel', new App::Panel::First);

  remove_panels
    Remove all the panels from the current panel.

    Example:

        $self->remove_panels;

  local_params
    Get the parameter list for the current panel. This fetches the parameter
    list and returns the parameters that are relevant to the current panel.
    This allows each panel to be written in isolation. Two panels may have
    input controls (textboxes etc) with the same name and they can each
    retrieve the value of that input from their %local_params hash.

    eg

        my %local_params = $self->local_params
        my $name = $local_params{name};

  event_button
    Display a button which when pressed re-cycles the application and
    generates an event to be handled by the next incarnation of the
    application. The name of the routine that will be called will have
    _event_ prepended. This is partly for aesthesic reasons but mainly for
    security, to stop a wily hacker from calling any routine by changing
    what is passed through the browser. We'll probably be encrypting what is
    passed through in a later version.

      Input:
        label:    Caption to display on button
        name:     Name of the event
        routine:  Name of the event routine to call
                  (defaults to name value if not specified)
                  ('_event_' is prepended to the routine name)
      eg:
        $shop->event_button(label   => 'Add Item',
                            name    => 'add',
                            routine => 'add');

  event_link
    Display a link (which can be an image link) which when pressed re-cycles
    the application and generates an event to be handled by the next
    incarnation of the application.

      Input:
        label:    Caption to display on link
         * OR *
        img:      Image to display as link

        name:     Name of the event
        routine:  Name of the event routine to call
                  (defaults to name value if not specified)
                  ('_event_' is prepended to the routine name)

      eg:
        $shop->event_link(label => 'Add Item',
                          name  => 'add')

  CGI input functions
    The CGI input functions are available here with local_ prepended so the
    name can be made panel-specific, and they can be called as a method.

